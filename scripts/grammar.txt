statements  : NEWLINE* statement (NEWLINE+ statement)* NEWLINE*

statement   : KEYWORD:return expr?
            : KEYWORD:continue
            : KEYWORD:break
            : expr

expr        : (KEYWORD:int|KEYWORD:float|KEYWORD:string|KEYWORD:boolean) IDENTIFIER EQ expr
            : comp-expr ((KEYWORD:and|KEYWORD:or) comp-expr)*
            
comp-expr   : not comp-expr
            : arith-expr ((EE|LT|GT|LTE|GTE) arith-expr)*    

arith-expr  : term ((PLUS|MINUS) term)*

term        : factor ((MUL|DIV) factor)*

factor      : (PLUS|MINUS) factor
            : power

power       : call (POW factor)*

call        : atom (LPAREN (expr (COMMA expr)*)? RPAREN)?

atom        : int|float|string|true|false|IDENTIFIER
            : LPAREN expr RPAREN
            : list-expr
            : if-expr
            : for-expr
            : while-expr
            : func-def
        
list_expr   : LSQUARE (expr (COMMA expr)*)? RSQUARE  

if-expr     : KEYWORD:if expr KEYWORD:then
              (statement if-expr-b|if-expr-c?)
              (NEWLINE statements KEYWORD:endif|if-expr-b|if-expr-c) 

if-expr-b   : KEYWORD:elif expr KEYWORD:then
              (statement if-expr-b|if-expr-c?)
              (NEWLINE statements KEYWORD:endif|if-expr-b|if-expr-c)     

if-expr-c   : KEYWORD:else
              statement
              (NEWLINE statements KEYWORD:endif)

for-expr    : KEYWORD:for IDENTIFIER EQ expr KEYWORD:to expr
              (KEYWORD:step expr)? KEYWORD:do 
              statement
              (NEWLINE statements KEYWORD:endfor)
        
while-expr  : KEYWORD:while expr KEYWORD:do
              statement
              (NEWLINE statements KEYWORD:endwhile)

func-def    : KEYWORD:fun IDENTIFIER?
              LPAREN ((KEYWORD:int|KEYWORD:float|KEYWORD:string|KEYWORD:boolean) IDENTIFIER (COMMA IDENTIFIER)*)? RPAREN
              (ARROW expr)
              (NEWLINE (KEYWORD:int|KEYWORD:float|KEYWORD:string|KEYWORD:boolean) KEYWORD:return statements KEYWORD:endfun)

---------------------------------------
OBS: 
    + indica um ou mais
    * indica zero ou mais
    ? indica que a expresão anterior é opcional

Ordem de prioridade (maior para o menor):
factor, term, expr
lparen/rparen, plus/minus, int/float, mul/div, plus/minus

atom = atomo

OBS: 
    Lado direito da potencia tem menos prioridade que o esquerdo

---------------------------------------
Variaveis:

IDENTIFIER
KEYWORKD
EQ 

VAR          variable_name      =       <expr>
 ^                ^             ^
KEYWORD       IDENTIFIER      EQUALS

---------------------------------------
A operacao de comparacao deve ter menos prioridade do que o parenteses
5 + 5 == 2 + 8

(5 + 5) == (2 + 8) # Queremos isso
5 + (5 == 2) + 8   # Isso nao pode acontecer


Operacao de comparacao deve ter mais prioridade 
do que uma atribuicao de variavel.

----------------------------------------
Exemplos da gramatica:

1 - expr: Expressão que começa com a declaração de uma variável seguida de uma atribuição:

        Exemplo: VAR x = 10

2 - comp-expr: Expressão de comparação:

        Exemplo: x > 5 and y <= 20 or z == 15

3 - arith-expr: Expressão aritmética:

        Exemplo: 3 + 2 * 5 - 4 / 2

4 - term: Termo aritmético:

        Exemplo: 2 * x

5 - factor: Fator aritmético:

        Exemplo: -y ou +5

6 - power: Expressão de potência:

        Exemplo: x ** 2 (x ao quadrado)

7 - atom: Átomo:

        Exemplos:
                10 (inteiro)
                3.14 (ponto flutuante)
                x (identificador)
                (3 + x) (expressão envolta por parênteses)

----------------------------------------
IF Statement
if <condition> then <expression> elif <condition> then <expression> else <expression>

if 5 == 5 then "Of course!" else "Maths is broken!"

----------------------------------------
FOR Statement

FOR <var_name> = <start_value> TO <end_value> then <expr>

int result = i
FOR i = 0 TO 10 then VAR result = result * i

STEP define o incremento ou decremento.

"STEP -1" indica que o contador "i" será decrementado em 1 
a cada iteração do loop FOR. Isso significa que o loop irá 
contar de 5 até 0, diminuindo 1 unidade a cada passo.

----------------------------------------
STRINGS

"Text"
"Text with \"quotes\""
"Text with \\ backslashes \\"
"Text \nwith \nnewlines"

----------------------------------------
LISTS
[]
[1, 2, 3, 4, 5]

[1, 2, 3] + 4 => [1, 2, 3, 4]
[1, 2, 3] * [3, 4, 5] => [1, 2, 3, 3, 4, 5]

[1, 2, 3] - 1 => [1, 3]
[1, 2, 3] - 0 => [2, 3]
[1, 2, 3] - -1 => [1, 2]
[1, 2, 3] - -2 => [1, 3]

[1, 2, 3] / 0 => 1
[1, 2, 3] / 1 => 2
[1, 2, 3] / -1 => 3

----------------------------------------
BUILD-IN FUNCTIONS

print
print_ret    -- Em vez de imprimir na tela, retornara o valor que esta sendo impresso
input
input_int
clear
is_number
is_string
is_list
is_function
append
pop
extend       -- Concatenar listas

----------------------------------------
Multi-line statements

PRINT("Hello")
PRINT("World")

PRINT("Hello"); PRINT("World")

--
if <expr> then <expr>

if <expr> then
  <expr1>
  <expr2>
  <expr3>
END

--
FOR i = 0 TO 10 then <expr> then

FOR i = 0 TO 10 then
  <expr1>
  <expr2>
  <expr3>
END

--
FUN <name>() -> <expr> 

FUN <name>()
  <expr1>
  <expr2>
  <expr3>
END

--
int a = if 5 == 5 then "Math works" else "Math is broken"

if 5 == 5 then   
  string a = "Math workd"
else
  string a = "Math is broken"
END

---------------------------------------
return, continue, break

FUN add(a, b)
  return a + b
END

FUN example()
  # algum codigo deve ser executado aqui
  if ... then
    return 
  END
  # mais codigo deve ser executado aqui
END

--
FOR i = 0 TO 10
  if somecondition then
    break
  END
  if someothercondition then
    continue
  END
  # mais codigo deve ser executado aqui
END

--
if condition then
  return
END

--
FUN myfuncA() -> myvalue

FUN myfuncB()
  # statement 1
  # statement 2
  RETURN myvalue
END

